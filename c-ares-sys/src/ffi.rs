/* automatically generated by rust-bindgen 0.72.0 */
#![allow(non_camel_case_types, non_snake_case)]
use c_types::fd_set;
use c_types::hostent;
use c_types::in_addr;
use c_types::iovec;
use c_types::sockaddr;
use c_types::socklen_t;
use libc::timeval;

#[cfg(target_os = "android")]
use jni_sys;

#[cfg(windows)]
pub type ares_socket_t = ::std::os::windows::io::RawSocket;
#[cfg(unix)]
pub type ares_socket_t = ::std::os::unix::io::RawFd;

pub type ares_socklen_t = socklen_t;
pub type ares_ssize_t = isize;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_status_t {
    ARES_SUCCESS = 0,
    ARES_ENODATA = 1,
    ARES_EFORMERR = 2,
    ARES_ESERVFAIL = 3,
    ARES_ENOTFOUND = 4,
    ARES_ENOTIMP = 5,
    ARES_EREFUSED = 6,
    ARES_EBADQUERY = 7,
    ARES_EBADNAME = 8,
    ARES_EBADFAMILY = 9,
    ARES_EBADRESP = 10,
    ARES_ECONNREFUSED = 11,
    ARES_ETIMEOUT = 12,
    ARES_EOF = 13,
    ARES_EFILE = 14,
    ARES_ENOMEM = 15,
    ARES_EDESTRUCTION = 16,
    ARES_EBADSTR = 17,
    ARES_EBADFLAGS = 18,
    ARES_ENONAME = 19,
    ARES_EBADHINTS = 20,
    ARES_ENOTINITIALIZED = 21,
    ARES_ELOADIPHLPAPI = 22,
    ARES_EADDRGETNETWORKPARAMS = 23,
    ARES_ECANCELLED = 24,
    ARES_ESERVICE = 25,
    ARES_ENOSERVER = 26,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_bool_t {
    ARES_FALSE = 0,
    ARES_TRUE = 1,
}
#[repr(u32)]
#[doc = " Values for ARES_OPT_EVENT_THREAD"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_evsys_t {
    #[doc = " Default (best choice) event system"]
    ARES_EVSYS_DEFAULT = 0,
    #[doc = " Win32 IOCP/AFD_POLL event system"]
    ARES_EVSYS_WIN32 = 1,
    #[doc = " Linux epoll"]
    ARES_EVSYS_EPOLL = 2,
    #[doc = " BSD/MacOS kqueue"]
    ARES_EVSYS_KQUEUE = 3,
    #[doc = " POSIX poll()"]
    ARES_EVSYS_POLL = 4,
    #[doc = " last fallback on Unix-like systems, select()"]
    ARES_EVSYS_SELECT = 5,
}
pub type ares_sock_state_cb = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        socket_fd: ares_socket_t,
        readable: ::std::os::raw::c_int,
        writable: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apattern {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_server_failover_options {
    pub retry_chance: ::std::os::raw::c_ushort,
    pub retry_delay: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_options {
    pub flags: ::std::os::raw::c_int,
    pub timeout: ::std::os::raw::c_int,
    pub tries: ::std::os::raw::c_int,
    pub ndots: ::std::os::raw::c_int,
    pub udp_port: ::std::os::raw::c_ushort,
    pub tcp_port: ::std::os::raw::c_ushort,
    pub socket_send_buffer_size: ::std::os::raw::c_int,
    pub socket_receive_buffer_size: ::std::os::raw::c_int,
    pub servers: *mut in_addr,
    pub nservers: ::std::os::raw::c_int,
    pub domains: *mut *mut ::std::os::raw::c_char,
    pub ndomains: ::std::os::raw::c_int,
    pub lookups: *mut ::std::os::raw::c_char,
    pub sock_state_cb: ares_sock_state_cb,
    pub sock_state_cb_data: *mut ::std::os::raw::c_void,
    pub sortlist: *mut apattern,
    pub nsort: ::std::os::raw::c_int,
    pub ednspsz: ::std::os::raw::c_int,
    #[cfg(cares1_15)]
    pub resolvconf_path: *mut ::std::os::raw::c_char,
    #[cfg(cares1_19)]
    pub hosts_path: *mut ::std::os::raw::c_char,
    #[cfg(cares1_20)]
    pub udp_max_queries: ::std::os::raw::c_int,
    #[cfg(cares1_22)]
    pub maxtimeout: ::std::os::raw::c_int,
    #[cfg(cares1_23)]
    pub qcache_max_ttl: ::std::os::raw::c_uint,
    #[cfg(cares1_26)]
    pub evsys: ares_evsys_t,
    #[cfg(cares1_29)]
    pub server_failover_opts: ares_server_failover_options,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_channeldata {
    _unused: [u8; 0],
}
pub type ares_channel = *mut ares_channeldata;
pub type ares_channel_t = ares_channeldata;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ares_in6_addr {
    pub _S6_un: ares_in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ares_in6_addr__bindgen_ty_1 {
    pub _S6_u8: [::std::os::raw::c_uchar; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ares_addr {
    pub family: ::std::os::raw::c_int,
    pub addr: ares_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ares_addr__bindgen_ty_1 {
    pub addr4: in_addr,
    pub addr6: ares_in6_addr,
}
#[repr(u32)]
#[doc = " DNS Record types handled by c-ares.  Some record types may only be valid\n  on requests (e.g. ARES_REC_TYPE_ANY), and some may only be valid on\n  responses"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_rec_type_t {
    #[doc = "< Host address."]
    ARES_REC_TYPE_A = 1,
    #[doc = "< Authoritative server."]
    ARES_REC_TYPE_NS = 2,
    #[doc = "< Canonical name."]
    ARES_REC_TYPE_CNAME = 5,
    #[doc = "< Start of authority zone."]
    ARES_REC_TYPE_SOA = 6,
    #[doc = "< Domain name pointer."]
    ARES_REC_TYPE_PTR = 12,
    #[doc = "< Host information."]
    ARES_REC_TYPE_HINFO = 13,
    #[doc = "< Mail routing information."]
    ARES_REC_TYPE_MX = 15,
    #[doc = "< Text strings."]
    ARES_REC_TYPE_TXT = 16,
    #[doc = "< RFC 2535 / RFC 2931. SIG Record"]
    ARES_REC_TYPE_SIG = 24,
    #[doc = "< RFC 3596. Ip6 Address."]
    ARES_REC_TYPE_AAAA = 28,
    #[doc = "< RFC 2782. Server Selection."]
    ARES_REC_TYPE_SRV = 33,
    #[doc = "< RFC 3403. Naming Authority Pointer"]
    ARES_REC_TYPE_NAPTR = 35,
    #[doc = "< RFC 6891. EDNS0 option (meta-RR)"]
    ARES_REC_TYPE_OPT = 41,
    #[doc = "< RFC 6698. DNS-Based Authentication of Named\n   Entities (DANE) Transport Layer Security\n   (TLS) Protocol: TLSA"]
    ARES_REC_TYPE_TLSA = 52,
    #[doc = "< RFC 9460. General Purpose Service Binding"]
    ARES_REC_TYPE_SVCB = 64,
    #[doc = "< RFC 9460. Service Binding type for use with\n   HTTPS"]
    ARES_REC_TYPE_HTTPS = 65,
    #[doc = "< Wildcard match.  Not response RR."]
    ARES_REC_TYPE_ANY = 255,
    #[doc = "< RFC 7553. Uniform Resource Identifier"]
    ARES_REC_TYPE_URI = 256,
    #[doc = "< RFC 6844. Certification Authority\n   Authorization."]
    ARES_REC_TYPE_CAA = 257,
    #[doc = "< Used as an indicator that the RR record\n   is not parsed, but provided in wire\n   format"]
    ARES_REC_TYPE_RAW_RR = 65536,
}
#[repr(u32)]
#[doc = " DNS Classes for requests and responses."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_class_t {
    #[doc = "< Internet"]
    ARES_CLASS_IN = 1,
    #[doc = "< CHAOS"]
    ARES_CLASS_CHAOS = 3,
    #[doc = "< Hesoid [Dyer 87]"]
    ARES_CLASS_HESOID = 4,
    #[doc = "< RFC 2136"]
    ARES_CLASS_NONE = 254,
    #[doc = "< Any class (requests only)"]
    ARES_CLASS_ANY = 255,
}
#[repr(u32)]
#[doc = " DNS RR Section type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_section_t {
    #[doc = "< Answer section"]
    ARES_SECTION_ANSWER = 1,
    #[doc = "< Authority section"]
    ARES_SECTION_AUTHORITY = 2,
    #[doc = "< Additional information section"]
    ARES_SECTION_ADDITIONAL = 3,
}
#[repr(u32)]
#[doc = " DNS Header opcodes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_opcode_t {
    #[doc = "< Standard query"]
    ARES_OPCODE_QUERY = 0,
    #[doc = "< Inverse query. Obsolete."]
    ARES_OPCODE_IQUERY = 1,
    #[doc = "< Name server status query"]
    ARES_OPCODE_STATUS = 2,
    #[doc = "< Zone change notification (RFC 1996)"]
    ARES_OPCODE_NOTIFY = 4,
    #[doc = "< Zone update message (RFC2136)"]
    ARES_OPCODE_UPDATE = 5,
}
#[repr(u32)]
#[doc = " DNS Header flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_flags_t {
    #[doc = "< QR. If set, is a response"]
    ARES_FLAG_QR = 1,
    #[doc = "< Authoritative Answer. If set, is authoritative"]
    ARES_FLAG_AA = 2,
    #[doc = "< Truncation. If set, is truncated response"]
    ARES_FLAG_TC = 4,
    #[doc = "< Recursion Desired. If set, recursion is desired"]
    ARES_FLAG_RD = 8,
    #[doc = "< Recursion Available. If set, server supports\n   recursion"]
    ARES_FLAG_RA = 16,
    #[doc = "< RFC 2065. Authentic Data bit indicates in a\n response that the data included has been verified by\n the server providing it"]
    ARES_FLAG_AD = 32,
    #[doc = "< RFC 2065. Checking Disabled bit indicates in a\n query that non-verified data is acceptable to the\n resolver sending the query."]
    ARES_FLAG_CD = 64,
}
#[repr(u32)]
#[doc = " DNS Response Codes from server"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_rcode_t {
    #[doc = "< Success"]
    ARES_RCODE_NOERROR = 0,
    #[doc = "< Format error. The name server was unable\n   to interpret the query."]
    ARES_RCODE_FORMERR = 1,
    #[doc = "< Server Failure. The name server was\n   unable to process this query due to a\n   problem with the nameserver"]
    ARES_RCODE_SERVFAIL = 2,
    #[doc = "< Name Error.  Meaningful only for\n   responses from an authoritative name\n   server, this code signifies that the\n   domain name referenced in the query does\n   not exist."]
    ARES_RCODE_NXDOMAIN = 3,
    #[doc = "< Not implemented.  The name server does\n   not support the requested kind of\n   query"]
    ARES_RCODE_NOTIMP = 4,
    #[doc = "< Refused. The name server refuses to\n   perform the specified operation for\n   policy reasons."]
    ARES_RCODE_REFUSED = 5,
    #[doc = "< RFC 2136. Some name that ought not to\n   exist, does exist."]
    ARES_RCODE_YXDOMAIN = 6,
    #[doc = "< RFC 2136. Some RRset that ought to not\n   exist, does exist."]
    ARES_RCODE_YXRRSET = 7,
    #[doc = "< RFC 2136. Some RRset that ought to exist,\n   does not exist."]
    ARES_RCODE_NXRRSET = 8,
    #[doc = "< RFC 2136. The server is not authoritative\n   for the zone named in the Zone section."]
    ARES_RCODE_NOTAUTH = 9,
    #[doc = "< RFC 2136. A name used in the Prerequisite\n   or Update Section is not within the zone\n   denoted by the Zone Section."]
    ARES_RCODE_NOTZONE = 10,
    #[doc = "< RFC 8409. DSO-TYPE Not implemented"]
    ARES_RCODE_DSOTYPEI = 11,
    #[doc = "< RFC 8945. TSIG Signature Failure"]
    ARES_RCODE_BADSIG = 16,
    #[doc = "< RFC 8945. Key not recognized."]
    ARES_RCODE_BADKEY = 17,
    #[doc = "< RFC 8945. Signature out of time window."]
    ARES_RCODE_BADTIME = 18,
    #[doc = "< RFC 2930. Bad TKEY Mode"]
    ARES_RCODE_BADMODE = 19,
    #[doc = "< RFC 2930. Duplicate Key Name"]
    ARES_RCODE_BADNAME = 20,
    #[doc = "< RFC 2930. Algorithm not supported"]
    ARES_RCODE_BADALG = 21,
    #[doc = "< RFC 8945. Bad Truncation"]
    ARES_RCODE_BADTRUNC = 22,
    #[doc = "< RFC 7873. Bad/missing Server Cookie"]
    ARES_RCODE_BADCOOKIE = 23,
}
#[repr(u32)]
#[doc = " Data types used"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_datatype_t {
    #[doc = "< struct in_addr * type"]
    ARES_DATATYPE_INADDR = 1,
    #[doc = "< struct ares_in6_addr * type"]
    ARES_DATATYPE_INADDR6 = 2,
    #[doc = "< 8bit unsigned integer"]
    ARES_DATATYPE_U8 = 3,
    #[doc = "< 16bit unsigned integer"]
    ARES_DATATYPE_U16 = 4,
    #[doc = "< 32bit unsigned integer"]
    ARES_DATATYPE_U32 = 5,
    #[doc = "< Null-terminated string of a domain name"]
    ARES_DATATYPE_NAME = 6,
    #[doc = "< Null-terminated string"]
    ARES_DATATYPE_STR = 7,
    #[doc = "< Binary data"]
    ARES_DATATYPE_BIN = 8,
    #[doc = "< Officially defined as binary data, but likely\n   printable. Guaranteed to have a NULL\n   terminator for convenience (not included in\n   length)"]
    ARES_DATATYPE_BINP = 9,
    #[doc = "< Array of options.  16bit identifier, BIN\n   data."]
    ARES_DATATYPE_OPT = 10,
    #[doc = "< Array of binary data, likely printable.\n   Guaranteed to have a NULL terminator for\n   convenience (not included in length)"]
    ARES_DATATYPE_ABINP = 11,
}
#[repr(u32)]
#[doc = " Keys used for all RR Types.  We take the record type and multiply by 100\n  to ensure we have a proper offset between keys so we can keep these sorted"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_rr_key_t {
    #[doc = " A Record. Address. Datatype: INADDR"]
    ARES_RR_A_ADDR = 101,
    #[doc = " NS Record. Name. Datatype: NAME"]
    ARES_RR_NS_NSDNAME = 201,
    #[doc = " CNAME Record. CName. Datatype: NAME"]
    ARES_RR_CNAME_CNAME = 501,
    #[doc = " SOA Record. MNAME, Primary Source of Data. Datatype: NAME"]
    ARES_RR_SOA_MNAME = 601,
    #[doc = " SOA Record. RNAME, Mailbox of person responsible. Datatype: NAME"]
    ARES_RR_SOA_RNAME = 602,
    #[doc = " SOA Record. Serial, version. Datatype: U32"]
    ARES_RR_SOA_SERIAL = 603,
    #[doc = " SOA Record. Refresh, zone refersh interval. Datatype: U32"]
    ARES_RR_SOA_REFRESH = 604,
    #[doc = " SOA Record. Retry, failed refresh retry interval. Datatype: U32"]
    ARES_RR_SOA_RETRY = 605,
    #[doc = " SOA Record. Expire, upper limit on authority. Datatype: U32"]
    ARES_RR_SOA_EXPIRE = 606,
    #[doc = " SOA Record. Minimum, RR TTL. Datatype: U32"]
    ARES_RR_SOA_MINIMUM = 607,
    #[doc = " PTR Record. DNAME, pointer domain. Datatype: NAME"]
    ARES_RR_PTR_DNAME = 1201,
    #[doc = " HINFO Record. CPU. Datatype: STR"]
    ARES_RR_HINFO_CPU = 1301,
    #[doc = " HINFO Record. OS. Datatype: STR"]
    ARES_RR_HINFO_OS = 1302,
    #[doc = " MX Record. Preference. Datatype: U16"]
    ARES_RR_MX_PREFERENCE = 1501,
    #[doc = " MX Record. Exchange, domain. Datatype: NAME"]
    ARES_RR_MX_EXCHANGE = 1502,
    #[doc = " TXT Record. Data. Datatype: ABINP"]
    ARES_RR_TXT_DATA = 1601,
    #[doc = " SIG Record. Type Covered. Datatype: U16"]
    ARES_RR_SIG_TYPE_COVERED = 2401,
    #[doc = " SIG Record. Algorithm. Datatype: U8"]
    ARES_RR_SIG_ALGORITHM = 2402,
    #[doc = " SIG Record. Labels. Datatype: U8"]
    ARES_RR_SIG_LABELS = 2403,
    #[doc = " SIG Record. Original TTL. Datatype: U32"]
    ARES_RR_SIG_ORIGINAL_TTL = 2404,
    #[doc = " SIG Record. Signature Expiration. Datatype: U32"]
    ARES_RR_SIG_EXPIRATION = 2405,
    #[doc = " SIG Record. Signature Inception. Datatype: U32"]
    ARES_RR_SIG_INCEPTION = 2406,
    #[doc = " SIG Record. Key Tag. Datatype: U16"]
    ARES_RR_SIG_KEY_TAG = 2407,
    #[doc = " SIG Record. Signers Name. Datatype: NAME"]
    ARES_RR_SIG_SIGNERS_NAME = 2408,
    #[doc = " SIG Record. Signature. Datatype: BIN"]
    ARES_RR_SIG_SIGNATURE = 2409,
    #[doc = " AAAA Record. Address. Datatype: INADDR6"]
    ARES_RR_AAAA_ADDR = 2801,
    #[doc = " SRV Record. Priority. Datatype: U16"]
    ARES_RR_SRV_PRIORITY = 3302,
    #[doc = " SRV Record. Weight. Datatype: U16"]
    ARES_RR_SRV_WEIGHT = 3303,
    #[doc = " SRV Record. Port. Datatype: U16"]
    ARES_RR_SRV_PORT = 3304,
    #[doc = " SRV Record. Target domain. Datatype: NAME"]
    ARES_RR_SRV_TARGET = 3305,
    #[doc = " NAPTR Record. Order. Datatype: U16"]
    ARES_RR_NAPTR_ORDER = 3501,
    #[doc = " NAPTR Record. Preference. Datatype: U16"]
    ARES_RR_NAPTR_PREFERENCE = 3502,
    #[doc = " NAPTR Record. Flags. Datatype: STR"]
    ARES_RR_NAPTR_FLAGS = 3503,
    #[doc = " NAPTR Record. Services. Datatype: STR"]
    ARES_RR_NAPTR_SERVICES = 3504,
    #[doc = " NAPTR Record. Regexp. Datatype: STR"]
    ARES_RR_NAPTR_REGEXP = 3505,
    #[doc = " NAPTR Record. Replacement. Datatype: NAME"]
    ARES_RR_NAPTR_REPLACEMENT = 3506,
    #[doc = " OPT Record. UDP Size. Datatype: U16"]
    ARES_RR_OPT_UDP_SIZE = 4101,
    #[doc = " OPT Record. Version. Datatype: U8"]
    ARES_RR_OPT_VERSION = 4103,
    #[doc = " OPT Record. Flags. Datatype: U16"]
    ARES_RR_OPT_FLAGS = 4104,
    #[doc = " OPT Record. Options. Datatype: OPT"]
    ARES_RR_OPT_OPTIONS = 4105,
    #[doc = " TLSA Record. Certificate Usage. Datatype: U8"]
    ARES_RR_TLSA_CERT_USAGE = 5201,
    #[doc = " TLSA Record. Selector. Datatype: U8"]
    ARES_RR_TLSA_SELECTOR = 5202,
    #[doc = " TLSA Record. Matching Type. Datatype: U8"]
    ARES_RR_TLSA_MATCH = 5203,
    #[doc = " TLSA Record. Certificate Association Data. Datatype: BIN"]
    ARES_RR_TLSA_DATA = 5204,
    #[doc = " SVCB Record. SvcPriority. Datatype: U16"]
    ARES_RR_SVCB_PRIORITY = 6401,
    #[doc = " SVCB Record. TargetName. Datatype: NAME"]
    ARES_RR_SVCB_TARGET = 6402,
    #[doc = " SVCB Record. SvcParams. Datatype: OPT"]
    ARES_RR_SVCB_PARAMS = 6403,
    #[doc = " HTTPS Record. SvcPriority. Datatype: U16"]
    ARES_RR_HTTPS_PRIORITY = 6501,
    #[doc = " HTTPS Record. TargetName. Datatype: NAME"]
    ARES_RR_HTTPS_TARGET = 6502,
    #[doc = " HTTPS Record. SvcParams. Datatype: OPT"]
    ARES_RR_HTTPS_PARAMS = 6503,
    #[doc = " URI Record. Priority. Datatype: U16"]
    ARES_RR_URI_PRIORITY = 25601,
    #[doc = " URI Record. Weight. Datatype: U16"]
    ARES_RR_URI_WEIGHT = 25602,
    #[doc = " URI Record. Target domain. Datatype: NAME"]
    ARES_RR_URI_TARGET = 25603,
    #[doc = " CAA Record. Critical flag. Datatype: U8"]
    ARES_RR_CAA_CRITICAL = 25701,
    #[doc = " CAA Record. Tag/Property. Datatype: STR"]
    ARES_RR_CAA_TAG = 25702,
    #[doc = " CAA Record. Value. Datatype: BINP"]
    ARES_RR_CAA_VALUE = 25703,
    #[doc = " RAW Record. RR Type. Datatype: U16"]
    ARES_RR_RAW_RR_TYPE = 6553601,
    #[doc = " RAW Record. RR Data. Datatype: BIN"]
    ARES_RR_RAW_RR_DATA = 6553602,
}
#[repr(u32)]
#[doc = " TLSA Record ARES_RR_TLSA_CERT_USAGE known values"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_tlsa_usage_t {
    #[doc = " Certificate Usage 0. CA Constraint."]
    ARES_TLSA_USAGE_CA = 0,
    #[doc = " Certificate Usage 1. Service Certificate Constraint."]
    ARES_TLSA_USAGE_SERVICE = 1,
    #[doc = " Certificate Usage 2. Trust Anchor Assertion."]
    ARES_TLSA_USAGE_TRUSTANCHOR = 2,
    #[doc = " Certificate Usage 3. Domain-issued certificate."]
    ARES_TLSA_USAGE_DOMAIN = 3,
}
#[repr(u32)]
#[doc = " TLSA Record ARES_RR_TLSA_SELECTOR known values"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_tlsa_selector_t {
    #[doc = " Full Certificate"]
    ARES_TLSA_SELECTOR_FULL = 0,
    #[doc = " DER-encoded SubjectPublicKeyInfo"]
    ARES_TLSA_SELECTOR_SUBJPUBKEYINFO = 1,
}
#[repr(u32)]
#[doc = " TLSA Record ARES_RR_TLSA_MATCH known values"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_tlsa_match_t {
    #[doc = " Exact match"]
    ARES_TLSA_MATCH_EXACT = 0,
    #[doc = " Sha256 match"]
    ARES_TLSA_MATCH_SHA256 = 1,
    #[doc = " Sha512 match"]
    ARES_TLSA_MATCH_SHA512 = 2,
}
#[repr(u32)]
#[doc = " SVCB (and HTTPS) RR known parameters"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_svcb_param_t {
    #[doc = " Mandatory keys in this RR (RFC 9460 Section 8)"]
    ARES_SVCB_PARAM_MANDATORY = 0,
    #[doc = " Additional supported protocols (RFC 9460 Section 7.1)"]
    ARES_SVCB_PARAM_ALPN = 1,
    #[doc = " No support for default protocol (RFC 9460 Section 7.1)"]
    ARES_SVCB_PARAM_NO_DEFAULT_ALPN = 2,
    #[doc = " Port for alternative endpoint (RFC 9460 Section 7.2)"]
    ARES_SVCB_PARAM_PORT = 3,
    #[doc = " IPv4 address hints (RFC 9460 Section 7.3)"]
    ARES_SVCB_PARAM_IPV4HINT = 4,
    #[doc = " RESERVED (held for Encrypted ClientHello)"]
    ARES_SVCB_PARAM_ECH = 5,
    #[doc = " IPv6 address hints (RFC 9460 Section 7.3)"]
    ARES_SVCB_PARAM_IPV6HINT = 6,
}
#[repr(u32)]
#[doc = " OPT RR known parameters"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_opt_param_t {
    #[doc = " RFC 8764. Apple's DNS Long-Lived Queries Protocol"]
    ARES_OPT_PARAM_LLQ = 1,
    #[doc = " http://files.dns-sd.org/draft-sekar-dns-ul.txt: Update Lease"]
    ARES_OPT_PARAM_UL = 2,
    #[doc = " RFC 5001. Name Server Identification"]
    ARES_OPT_PARAM_NSID = 3,
    #[doc = " RFC 6975. DNSSEC Algorithm Understood"]
    ARES_OPT_PARAM_DAU = 5,
    #[doc = " RFC 6975. DS Hash Understood"]
    ARES_OPT_PARAM_DHU = 6,
    #[doc = " RFC 6975. NSEC3 Hash Understood"]
    ARES_OPT_PARAM_N3U = 7,
    #[doc = " RFC 7871. Client Subnet"]
    ARES_OPT_PARAM_EDNS_CLIENT_SUBNET = 8,
    #[doc = " RFC 7314. Expire Timer"]
    ARES_OPT_PARAM_EDNS_EXPIRE = 9,
    #[doc = " RFC 7873. Client and Server Cookies"]
    ARES_OPT_PARAM_COOKIE = 10,
    #[doc = " RFC 7828. TCP Keepalive timeout"]
    ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE = 11,
    #[doc = " RFC 7830. Padding"]
    ARES_OPT_PARAM_PADDING = 12,
    #[doc = " RFC 7901. Chain query requests"]
    ARES_OPT_PARAM_CHAIN = 13,
    #[doc = " RFC 8145. Signaling Trust Anchor Knowledge in DNSSEC"]
    ARES_OPT_PARAM_EDNS_KEY_TAG = 14,
    #[doc = " RFC 8914. Extended ERROR code and message"]
    ARES_OPT_PARAM_EXTENDED_DNS_ERROR = 15,
}
#[repr(u32)]
#[doc = " Data type for option records for keys like ARES_RR_OPT_OPTIONS and\n  ARES_RR_HTTPS_PARAMS returned by ares_dns_opt_get_datatype()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_opt_datatype_t {
    #[doc = " No value allowed for this option"]
    ARES_OPT_DATATYPE_NONE = 1,
    #[doc = " List of strings, each prefixed with a single octet representing the length"]
    ARES_OPT_DATATYPE_STR_LIST = 2,
    #[doc = " List of 8bit integers, concatenated"]
    ARES_OPT_DATATYPE_U8_LIST = 3,
    #[doc = " 16bit integer in network byte order"]
    ARES_OPT_DATATYPE_U16 = 4,
    #[doc = " list of 16bit integer in network byte order, concatenated."]
    ARES_OPT_DATATYPE_U16_LIST = 5,
    #[doc = " 32bit integer in network byte order"]
    ARES_OPT_DATATYPE_U32 = 6,
    #[doc = " list 32bit integer in network byte order, concatenated"]
    ARES_OPT_DATATYPE_U32_LIST = 7,
    #[doc = " List of ipv4 addresses in network byte order, concatenated"]
    ARES_OPT_DATATYPE_INADDR4_LIST = 8,
    #[doc = " List of ipv6 addresses in network byte order, concatenated"]
    ARES_OPT_DATATYPE_INADDR6_LIST = 9,
    #[doc = " Binary Data"]
    ARES_OPT_DATATYPE_BIN = 10,
    #[doc = " DNS Domain Name Format"]
    ARES_OPT_DATATYPE_NAME = 11,
}
#[repr(u32)]
#[doc = " Data type for flags to ares_dns_parse()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_dns_parse_flags_t {
    #[doc = " Parse Answers from RFC 1035 that allow name compression as RAW"]
    ARES_DNS_PARSE_AN_BASE_RAW = 1,
    #[doc = " Parse Authority from RFC 1035 that allow name compression as RAW"]
    ARES_DNS_PARSE_NS_BASE_RAW = 2,
    #[doc = " Parse Additional from RFC 1035 that allow name compression as RAW"]
    ARES_DNS_PARSE_AR_BASE_RAW = 4,
    #[doc = " Parse Answers from later RFCs (no name compression) RAW"]
    ARES_DNS_PARSE_AN_EXT_RAW = 8,
    #[doc = " Parse Authority from later RFCs (no name compression) as RAW"]
    ARES_DNS_PARSE_NS_EXT_RAW = 16,
    #[doc = " Parse Additional from later RFCs (no name compression) as RAW"]
    ARES_DNS_PARSE_AR_EXT_RAW = 32,
}
unsafe extern "C" {
    #[doc = " String representation of DNS Record Type\n\n  \\param[in] type  DNS Record Type\n  \\return string"]
    pub fn ares_dns_rec_type_tostr(type_: ares_dns_rec_type_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " String representation of DNS Class\n\n  \\param[in] qclass  DNS Class\n  \\return string"]
    pub fn ares_dns_class_tostr(qclass: ares_dns_class_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " String representation of DNS OpCode\n\n  \\param[in] opcode  DNS OpCode\n  \\return string"]
    pub fn ares_dns_opcode_tostr(opcode: ares_dns_opcode_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " String representation of DNS Resource Record Parameter\n\n  \\param[in] key  DNS Resource Record parameter\n  \\return string"]
    pub fn ares_dns_rr_key_tostr(key: ares_dns_rr_key_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " String representation of DNS Resource Record section\n\n \\param[in] section  Section\n \\return string"]
    pub fn ares_dns_section_tostr(section: ares_dns_section_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert DNS class name as string to ares_dns_class_t\n\n  \\param[out] qclass  Pointer passed by reference to write class\n  \\param[in]  str     String to convert\n  \\return ARES_TRUE on success"]
    pub fn ares_dns_class_fromstr(
        qclass: *mut ares_dns_class_t,
        str_: *const ::std::os::raw::c_char,
    ) -> ares_bool_t;
}
unsafe extern "C" {
    #[doc = " Convert DNS record type as string to ares_dns_rec_type_t\n\n  \\param[out] qtype   Pointer passed by reference to write record type\n  \\param[in]  str     String to convert\n  \\return ARES_TRUE on success"]
    pub fn ares_dns_rec_type_fromstr(
        qtype: *mut ares_dns_rec_type_t,
        str_: *const ::std::os::raw::c_char,
    ) -> ares_bool_t;
}
unsafe extern "C" {
    #[doc = " Convert DNS response code as string to from ares_dns_rcode_t\n\n  \\param[in] rcode  Response code to convert\n  \\return ARES_TRUE on success"]
    pub fn ares_dns_rcode_tostr(rcode: ares_dns_rcode_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert any valid ip address (ipv4 or ipv6) into struct ares_addr and\n  return the starting pointer of the network byte order address and the\n  length of the address (4 or 16).\n\n  \\param[in]     ipaddr  ASCII string form of the ip address\n  \\param[in,out] addr    Must set \"family\" member to one of AF_UNSPEC,\n                         AF_INET, AF_INET6 on input.\n  \\param[out]    out_len Length of binary form address\n  \\return Pointer to start of binary address or NULL on error."]
    pub fn ares_dns_pton(
        ipaddr: *const ::std::os::raw::c_char,
        addr: *mut ares_addr,
        out_len: *mut usize,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Convert an ip address into the PTR format for in-addr.arpa or in6.arpa\n\n  \\param[in]  addr  properly filled address structure\n  \\return  String representing PTR, use ares_free_string() to free"]
    pub fn ares_dns_addr_to_ptr(addr: *const ares_addr) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " The options/parameters extensions to some RRs can be somewhat opaque, this\n  is a helper to return the best match for a datatype for interpreting the\n  option record.\n\n  \\param[in] key  Key associated with options/parameters\n  \\param[in] opt  Option Key/Parameter\n  \\return Datatype"]
    pub fn ares_dns_opt_get_datatype(
        key: ares_dns_rr_key_t,
        opt: ::std::os::raw::c_ushort,
    ) -> ares_dns_opt_datatype_t;
}
unsafe extern "C" {
    #[doc = " The options/parameters extensions to some RRs can be somewhat opaque, this\n  is a helper to return the name if the option is known.\n\n  \\param[in] key  Key associated with options/parameters\n  \\param[in] opt  Option Key/Parameter\n  \\return name, or NULL if not known."]
    pub fn ares_dns_opt_get_name(
        key: ares_dns_rr_key_t,
        opt: ::std::os::raw::c_ushort,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve a list of Resource Record keys that can be set or retrieved for\n  the Resource record type.\n\n  \\param[in]  type  Record Type\n  \\param[out] cnt   Number of keys returned\n  \\return array of keys associated with Resource Record"]
    pub fn ares_dns_rr_get_keys(
        type_: ares_dns_rec_type_t,
        cnt: *mut usize,
    ) -> *const ares_dns_rr_key_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the datatype associated with a Resource Record key.\n\n  \\param[in] key   Resource Record Key\n  \\return datatype"]
    pub fn ares_dns_rr_key_datatype(key: ares_dns_rr_key_t) -> ares_dns_datatype_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the DNS Resource Record type associated with a Resource Record key.\n\n  \\param[in] key   Resource Record Key\n  \\return DNS Resource Record Type"]
    pub fn ares_dns_rr_key_to_rec_type(key: ares_dns_rr_key_t) -> ares_dns_rec_type_t;
}
#[doc = " Opaque data type representing a DNS RR (Resource Record)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_dns_rr {
    _unused: [u8; 0],
}
#[doc = " Typedef for opaque data type representing a DNS RR (Resource Record)"]
pub type ares_dns_rr_t = ares_dns_rr;
#[doc = " Opaque data type representing a DNS Query Data QD Packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_dns_qd {
    _unused: [u8; 0],
}
#[doc = " Typedef for opaque data type representing a DNS Query Data QD Packet"]
pub type ares_dns_qd_t = ares_dns_qd;
#[doc = " Opaque data type representing a DNS Packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_dns_record {
    _unused: [u8; 0],
}
#[doc = " Typedef for opaque data type representing a DNS Packet"]
pub type ares_dns_record_t = ares_dns_record;
unsafe extern "C" {
    #[doc = " Create a new DNS record object\n\n  \\param[out] dnsrec  Pointer passed by reference for a newly allocated\n                      record object.  Must be ares_dns_record_destroy()'d by\n                      caller.\n  \\param[in]  id      DNS Query ID.  If structuring a new query to be sent\n                      with ares_send(), this value should be zero.\n  \\param[in]  flags   DNS Flags from \\ares_dns_flags_t\n  \\param[in]  opcode  DNS OpCode (typically ARES_OPCODE_QUERY)\n  \\param[in]  rcode   DNS RCode\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_record_create(
        dnsrec: *mut *mut ares_dns_record_t,
        id: ::std::os::raw::c_ushort,
        flags: ::std::os::raw::c_ushort,
        opcode: ares_dns_opcode_t,
        rcode: ares_dns_rcode_t,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Destroy a DNS record object\n\n  \\param[in] dnsrec  Initialized record object"]
    pub fn ares_dns_record_destroy(dnsrec: *mut ares_dns_record_t);
}
unsafe extern "C" {
    #[doc = " Get the DNS Query ID\n\n  \\param[in] dnsrec  Initialized record object\n  \\return DNS query id"]
    pub fn ares_dns_record_get_id(dnsrec: *const ares_dns_record_t) -> ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    #[doc = " Overwrite the DNS query id\n\n \\param[in] dnsrec  Initialized record object\n \\param[in] id      DNS query id\n \\return ARES_TRUE on success, ARES_FALSE on usage error"]
    pub fn ares_dns_record_set_id(
        dnsrec: *mut ares_dns_record_t,
        id: ::std::os::raw::c_ushort,
    ) -> ares_bool_t;
}
unsafe extern "C" {
    #[doc = " Get the DNS Record Flags\n\n  \\param[in] dnsrec  Initialized record object\n  \\return One or more \\ares_dns_flags_t"]
    pub fn ares_dns_record_get_flags(dnsrec: *const ares_dns_record_t) -> ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    #[doc = " Get the DNS Record OpCode\n\n  \\param[in] dnsrec  Initialized record object\n  \\return opcode"]
    pub fn ares_dns_record_get_opcode(dnsrec: *const ares_dns_record_t) -> ares_dns_opcode_t;
}
unsafe extern "C" {
    #[doc = " Get the DNS Record RCode\n\n  \\param[in] dnsrec  Initialized record object\n  \\return rcode"]
    pub fn ares_dns_record_get_rcode(dnsrec: *const ares_dns_record_t) -> ares_dns_rcode_t;
}
unsafe extern "C" {
    #[doc = " Add a query to the DNS Record.  Typically a record will have only 1\n  query. Most DNS servers will reject queries with more than 1 question.\n\n \\param[in] dnsrec  Initialized record object\n \\param[in] name    Name/Hostname of request\n \\param[in] qtype   Type of query\n \\param[in] qclass  Class of query (typically ARES_CLASS_IN)\n \\return ARES_SUCCESS on success"]
    pub fn ares_dns_record_query_add(
        dnsrec: *mut ares_dns_record_t,
        name: *const ::std::os::raw::c_char,
        qtype: ares_dns_rec_type_t,
        qclass: ares_dns_class_t,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Replace the question name with a new name.  This may be used when performing\n  a search with aliases.\n\n  Note that this will invalidate the name pointer returned from\n  ares_dns_record_query_get().\n\n \\param[in] dnsrec  Initialized record object\n \\param[in] idx     Index of question (typically 0)\n \\param[in] name    Name to use as replacement.\n \\return ARES_SUCCESS on success"]
    pub fn ares_dns_record_query_set_name(
        dnsrec: *mut ares_dns_record_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Replace the question type with a different type.  This may be used when\n  needing to query more than one address class (e.g. A and AAAA)\n\n \\param[in] dnsrec  Initialized record object\n \\param[in] idx     Index of question (typically 0)\n \\param[in] qtype   Record Type to use as replacement.\n \\return ARES_SUCCESS on success"]
    pub fn ares_dns_record_query_set_type(
        dnsrec: *mut ares_dns_record_t,
        idx: usize,
        qtype: ares_dns_rec_type_t,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Get the count of queries in the DNS Record\n\n \\param[in] dnsrec  Initialized record object\n \\return count of queries"]
    pub fn ares_dns_record_query_cnt(dnsrec: *const ares_dns_record_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Get the data about the query at the provided index.\n\n \\param[in]  dnsrec  Initialized record object\n \\param[in]  idx     Index of query\n \\param[out] name    Optional.  Returns name, may pass NULL if not desired.\n                     This pointer will be invalided by any call to\n                     ares_dns_record_query_set_name().\n \\param[out] qtype   Optional.  Returns record type, may pass NULL.\n \\param[out] qclass  Optional.  Returns class, may pass NULL.\n \\return ARES_SUCCESS on success"]
    pub fn ares_dns_record_query_get(
        dnsrec: *const ares_dns_record_t,
        idx: usize,
        name: *mut *const ::std::os::raw::c_char,
        qtype: *mut ares_dns_rec_type_t,
        qclass: *mut ares_dns_class_t,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Get the count of Resource Records in the provided section\n\n \\param[in] dnsrec  Initialized record object\n \\param[in] sect    Section.  ARES_SECTION_ANSWER is most used.\n \\return count of resource records."]
    pub fn ares_dns_record_rr_cnt(
        dnsrec: *const ares_dns_record_t,
        sect: ares_dns_section_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Add a Resource Record to the DNS Record.\n\n  \\param[out] rr_out   Pointer to created resource record.  This pointer\n                       is owned by the DNS record itself, this is just made\n                       available to facilitate adding RR-specific fields.\n  \\param[in]  dnsrec   Initialized record object\n  \\param[in]  sect     Section to add resource record to\n  \\param[in]  name     Resource Record name/hostname\n  \\param[in]  type     Record Type\n  \\param[in]  rclass   Class\n  \\param[in]  ttl      TTL\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_record_rr_add(
        rr_out: *mut *mut ares_dns_rr_t,
        dnsrec: *mut ares_dns_record_t,
        sect: ares_dns_section_t,
        name: *const ::std::os::raw::c_char,
        type_: ares_dns_rec_type_t,
        rclass: ares_dns_class_t,
        ttl: ::std::os::raw::c_uint,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Fetch a writable resource record based on the section and index.\n\n  \\param[in]  dnsrec   Initialized record object\n  \\param[in]  sect     Section for resource record\n  \\param[in]  idx      Index of resource record in section\n  \\return NULL on misuse, otherwise a writable pointer to the resource record"]
    pub fn ares_dns_record_rr_get(
        dnsrec: *mut ares_dns_record_t,
        sect: ares_dns_section_t,
        idx: usize,
    ) -> *mut ares_dns_rr_t;
}
unsafe extern "C" {
    #[doc = " Fetch a non-writeable resource record based on the section and index.\n\n  \\param[in]  dnsrec   Initialized record object\n  \\param[in]  sect     Section for resource record\n  \\param[in]  idx      Index of resource record in section\n  \\return NULL on misuse, otherwise a const pointer to the resource record"]
    pub fn ares_dns_record_rr_get_const(
        dnsrec: *const ares_dns_record_t,
        sect: ares_dns_section_t,
        idx: usize,
    ) -> *const ares_dns_rr_t;
}
unsafe extern "C" {
    #[doc = " Remove the resource record based on the section and index\n\n  \\param[in]  dnsrec   Initialized record object\n  \\param[in]  sect     Section for resource record\n  \\param[in]  idx      Index of resource record in section\n  \\return ARES_SUCCESS on success, otherwise an error code."]
    pub fn ares_dns_record_rr_del(
        dnsrec: *mut ares_dns_record_t,
        sect: ares_dns_section_t,
        idx: usize,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the resource record Name/Hostname\n\n  \\param[in] rr  Pointer to resource record\n  \\return Name"]
    pub fn ares_dns_rr_get_name(rr: *const ares_dns_rr_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the resource record type\n\n  \\param[in] rr  Pointer to resource record\n  \\return type"]
    pub fn ares_dns_rr_get_type(rr: *const ares_dns_rr_t) -> ares_dns_rec_type_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the resource record class\n\n  \\param[in] rr  Pointer to resource record\n  \\return class"]
    pub fn ares_dns_rr_get_class(rr: *const ares_dns_rr_t) -> ares_dns_class_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the resource record TTL\n\n  \\param[in] rr  Pointer to resource record\n  \\return TTL"]
    pub fn ares_dns_rr_get_ttl(rr: *const ares_dns_rr_t) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Set ipv4 address data type for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_INADDR\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] addr   Pointer to ipv4 address to use.\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_addr(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        addr: *const in_addr,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set ipv6 address data type for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_INADDR6\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] addr   Pointer to ipv6 address to use.\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_addr6(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        addr: *const ares_in6_addr,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set string data for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_STR or ARES_DATATYPE_NAME.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] val    Pointer to string to set.\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_str(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        val: *const ::std::os::raw::c_char,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set 8bit unsigned integer for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_U8\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] val    8bit unsigned integer\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_u8(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        val: ::std::os::raw::c_uchar,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set 16bit unsigned integer for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_U16\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] val    16bit unsigned integer\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_u16(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        val: ::std::os::raw::c_ushort,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set 32bit unsigned integer for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_U32\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] val    32bit unsigned integer\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_u32(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        val: ::std::os::raw::c_uint,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set binary (BIN or BINP) data for specified resource record and key.  Can\n  only be used on keys with datatype ARES_DATATYPE_BIN or ARES_DATATYPE_BINP.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] val    Pointer to binary data.\n  \\param[in] len    Length of binary data\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_bin(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        val: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Add binary array value (ABINP) data for specified resource record and key.\n  Can only be used on keys with datatype ARES_DATATYPE_ABINP.  The value will\n  Be added as the last element in the array.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] val    Pointer to binary data.\n  \\param[in] len    Length of binary data\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_add_abin(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        val: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Delete binary array value (ABINP) data for specified resource record and\n  key by specified index. Can only be used on keys with datatype\n  ARES_DATATYPE_ABINP.  The value at the index will be deleted.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\param[in] idx    Index to delete\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_del_abin(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        idx: usize,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Set the option for the RR\n\n  \\param[in]  dns_rr   Pointer to resource record\n  \\param[in]  key      DNS Resource Record Key\n  \\param[in]  opt      Option record key id.\n  \\param[out] val      Optional. Value to associate with option.\n  \\param[out] val_len  Length of value passed.\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_rr_set_opt(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        opt: ::std::os::raw::c_ushort,
        val: *const ::std::os::raw::c_uchar,
        val_len: usize,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Delete the option for the RR by id\n\n  \\param[in] dns_rr   Pointer to resource record\n  \\param[in] key      DNS Resource Record Key\n  \\param[in] opt      Option record key id.\n  \\return ARES_SUCCESS if removed, ARES_ENOTFOUND if not found"]
    pub fn ares_dns_rr_del_opt_byid(
        dns_rr: *mut ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        opt: ::std::os::raw::c_ushort,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Retrieve a pointer to the ipv4 address.  Can only be used on keys with\n  datatype ARES_DATATYPE_INADDR.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return pointer to ipv4 address or NULL on error"]
    pub fn ares_dns_rr_get_addr(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
    ) -> *const in_addr;
}
unsafe extern "C" {
    #[doc = " Retrieve a pointer to the ipv6 address.  Can only be used on keys with\n  datatype ARES_DATATYPE_INADDR6.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return pointer to ipv6 address or NULL on error"]
    pub fn ares_dns_rr_get_addr6(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
    ) -> *const ares_in6_addr;
}
unsafe extern "C" {
    #[doc = " Retrieve a pointer to the string.  Can only be used on keys with\n  datatype ARES_DATATYPE_STR and ARES_DATATYPE_NAME.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return pointer string or NULL on error"]
    pub fn ares_dns_rr_get_str(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve an 8bit unsigned integer.  Can only be used on keys with\n  datatype ARES_DATATYPE_U8.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return 8bit unsigned integer"]
    pub fn ares_dns_rr_get_u8(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
    ) -> ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = " Retrieve an 16bit unsigned integer.  Can only be used on keys with\n  datatype ARES_DATATYPE_U16.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return 16bit unsigned integer"]
    pub fn ares_dns_rr_get_u16(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
    ) -> ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    #[doc = " Retrieve an 32bit unsigned integer.  Can only be used on keys with\n  datatype ARES_DATATYPE_U32.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return 32bit unsigned integer"]
    pub fn ares_dns_rr_get_u32(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Retrieve a pointer to the binary data.  Can only be used on keys with\n  datatype ARES_DATATYPE_BIN, ARES_DATATYPE_BINP, or ARES_DATATYPE_ABINP.\n  If BINP or ABINP, the data is guaranteed to have a NULL terminator which\n  is NOT included in the length.\n\n  \\param[in]  dns_rr Pointer to resource record\n  \\param[in]  key    DNS Resource Record Key\n  \\param[out] len    Length of binary data returned\n  \\return pointer binary data or NULL on error"]
    pub fn ares_dns_rr_get_bin(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = " Retrieve the count of the array of stored binary values. Can only be used on\n  keys with datatype ARES_DATATYPE_ABINP.\n\n  \\param[in]  dns_rr Pointer to resource record\n  \\param[in]  key    DNS Resource Record Key\n  \\return count of values"]
    pub fn ares_dns_rr_get_abin_cnt(dns_rr: *const ares_dns_rr_t, key: ares_dns_rr_key_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Retrieve a pointer to the binary array data from the specified index.  Can\n  only be used on keys with datatype ARES_DATATYPE_ABINP.  If ABINP, the data\n  is guaranteed to have a NULL terminator which is NOT included in the length.\n  If want all array membersconcatenated, may use ares_dns_rr_get_bin()\n  instead.\n\n  \\param[in]  dns_rr Pointer to resource record\n  \\param[in]  key    DNS Resource Record Key\n  \\param[in]  idx    Index of value to retrieve\n  \\param[out] len    Length of binary data returned\n  \\return pointer binary data or NULL on error"]
    pub fn ares_dns_rr_get_abin(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        idx: usize,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = " Retrieve the number of options stored for the RR.\n\n  \\param[in] dns_rr Pointer to resource record\n  \\param[in] key    DNS Resource Record Key\n  \\return count, or 0 if none."]
    pub fn ares_dns_rr_get_opt_cnt(dns_rr: *const ares_dns_rr_t, key: ares_dns_rr_key_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Retrieve the option for the RR by index.\n\n  \\param[in]  dns_rr  Pointer to resource record\n  \\param[in]  key     DNS Resource Record Key\n  \\param[in]  idx     Index of option record\n  \\param[out] val     Optional. Pointer passed by reference to hold value.\n                      Options may not have values.  Value if returned is\n                      guaranteed to be NULL terminated, however in most\n                      cases it is not printable.\n  \\param[out] val_len Optional. Pointer passed by reference to hold value\n                      length.\n  \\return option key/id on success, 65535 on misuse."]
    pub fn ares_dns_rr_get_opt(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        idx: usize,
        val: *mut *const ::std::os::raw::c_uchar,
        val_len: *mut usize,
    ) -> ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    #[doc = " Retrieve the option for the RR by the option key/id.\n\n  \\param[in]  dns_rr  Pointer to resource record\n  \\param[in]  key     DNS Resource Record Key\n  \\param[in]  opt     Option record key id (this is not the index).\n  \\param[out] val     Optional. Pointer passed by reference to hold value.\n                      Options may not have values. Value if returned is\n                      guaranteed to be NULL terminated, however in most cases\n                      it is not printable.\n  \\param[out] val_len Optional. Pointer passed by reference to hold value\n                      length.\n  \\return ARES_TRUE on success, ARES_FALSE on misuse."]
    pub fn ares_dns_rr_get_opt_byid(
        dns_rr: *const ares_dns_rr_t,
        key: ares_dns_rr_key_t,
        opt: ::std::os::raw::c_ushort,
        val: *mut *const ::std::os::raw::c_uchar,
        val_len: *mut usize,
    ) -> ares_bool_t;
}
unsafe extern "C" {
    #[doc = " Parse a complete DNS message.\n\n  \\param[in]  buf      pointer to bytes to be parsed\n  \\param[in]  buf_len  Length of buf provided\n  \\param[in]  flags    Flags dictating how the message should be parsed.\n  \\param[out] dnsrec   Pointer passed by reference for a new DNS record object\n                       that must be ares_dns_record_destroy()'d by caller.\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_parse(
        buf: *const ::std::os::raw::c_uchar,
        buf_len: usize,
        flags: ::std::os::raw::c_uint,
        dnsrec: *mut *mut ares_dns_record_t,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Write a complete DNS message\n\n  \\param[in]  dnsrec   Pointer to initialized and filled DNS record object.\n  \\param[out] buf      Pointer passed by reference to be filled in with with\n                       DNS message.  Must be ares_free()'d by caller.\n  \\param[out] buf_len  Length of returned buffer containing DNS message.\n  \\return ARES_SUCCESS on success"]
    pub fn ares_dns_write(
        dnsrec: *const ares_dns_record_t,
        buf: *mut *mut ::std::os::raw::c_uchar,
        buf_len: *mut usize,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Duplicate a complete DNS message.  This does not copy internal members\n  (such as the ttl decrement capability).\n\n  Returns NULL if \\p dnsrec is NULL.\n\n  \\param[in] dnsrec Pointer to initialized and filled DNS record object.\n  \\return duplicated DNS record object, or NULL on out of memory."]
    pub fn ares_dns_record_duplicate(dnsrec: *const ares_dns_record_t) -> *mut ares_dns_record_t;
}
pub type ares_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        status: ::std::os::raw::c_int,
        timeouts: ::std::os::raw::c_int,
        abuf: *mut ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
    ),
>;
pub type ares_callback_dnsrec = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        status: ares_status_t,
        timeouts: usize,
        dnsrec: *const ares_dns_record_t,
    ),
>;
pub type ares_host_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        status: ::std::os::raw::c_int,
        timeouts: ::std::os::raw::c_int,
        hostent: *mut hostent,
    ),
>;
pub type ares_nameinfo_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        status: ::std::os::raw::c_int,
        timeouts: ::std::os::raw::c_int,
        node: *mut ::std::os::raw::c_char,
        service: *mut ::std::os::raw::c_char,
    ),
>;
pub type ares_sock_create_callback = ::std::option::Option<
    unsafe extern "C" fn(
        socket_fd: ares_socket_t,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ares_sock_config_callback = ::std::option::Option<
    unsafe extern "C" fn(
        socket_fd: ares_socket_t,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ares_addrinfo_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        status: ::std::os::raw::c_int,
        timeouts: ::std::os::raw::c_int,
        res: *mut ares_addrinfo,
    ),
>;
pub type ares_server_state_callback = ::std::option::Option<
    unsafe extern "C" fn(
        server_string: *const ::std::os::raw::c_char,
        success: ares_bool_t,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ares_pending_write_cb =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type ares_query_enqueue_cb =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn ares_library_init(flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_library_init_mem(
        flags: ::std::os::raw::c_int,
        amalloc: ::std::option::Option<
            unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void,
        >,
        afree: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
        arealloc: ::std::option::Option<
            unsafe extern "C" fn(
                ptr: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_library_initialized() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_library_cleanup();
}
unsafe extern "C" {
    pub fn ares_version(version: *mut ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ares_init(channelptr: *mut *mut ares_channel_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_init_options(
        channelptr: *mut *mut ares_channel_t,
        options: *const ares_options,
        optmask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_save_options(
        channel: *const ares_channel_t,
        options: *mut ares_options,
        optmask: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_destroy_options(options: *mut ares_options);
}
unsafe extern "C" {
    pub fn ares_dup(
        dest: *mut *mut ares_channel_t,
        src: *const ares_channel_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_reinit(channel: *mut ares_channel_t) -> ares_status_t;
}
unsafe extern "C" {
    pub fn ares_destroy(channel: *mut ares_channel_t);
}
unsafe extern "C" {
    pub fn ares_cancel(channel: *mut ares_channel_t);
}
unsafe extern "C" {
    pub fn ares_set_local_ip4(channel: *mut ares_channel_t, local_ip: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn ares_set_local_ip6(
        channel: *mut ares_channel_t,
        local_ip6: *const ::std::os::raw::c_uchar,
    );
}
unsafe extern "C" {
    pub fn ares_set_local_dev(
        channel: *mut ares_channel_t,
        local_dev_name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn ares_set_socket_callback(
        channel: *mut ares_channel_t,
        callback: ares_sock_create_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_set_socket_configure_callback(
        channel: *mut ares_channel_t,
        callback: ares_sock_config_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_set_server_state_callback(
        channel: *mut ares_channel_t,
        callback: ares_server_state_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_set_pending_write_cb(
        channel: *mut ares_channel_t,
        callback: ares_pending_write_cb,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_set_query_enqueue_cb(
        channel: *mut ares_channel_t,
        callback: ares_query_enqueue_cb,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_process_pending_write(channel: *mut ares_channel_t);
}
unsafe extern "C" {
    pub fn ares_set_sortlist(
        channel: *mut ares_channel_t,
        sortstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_getaddrinfo(
        channel: *mut ares_channel_t,
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const ares_addrinfo_hints,
        callback: ares_addrinfo_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_freeaddrinfo(ai: *mut ares_addrinfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_socket_functions {
    pub asocket: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ares_socket_t,
    >,
    pub aclose: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ares_socket_t,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub aconnect: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ares_socket_t,
            arg2: *const sockaddr,
            arg3: ares_socklen_t,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub arecvfrom: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ares_socket_t,
            arg2: *mut ::std::os::raw::c_void,
            arg3: usize,
            arg4: ::std::os::raw::c_int,
            arg5: *mut sockaddr,
            arg6: *mut ares_socklen_t,
            arg7: *mut ::std::os::raw::c_void,
        ) -> ares_ssize_t,
    >,
    pub asendv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ares_socket_t,
            arg2: *const iovec,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ares_ssize_t,
    >,
}
unsafe extern "C" {
    pub fn ares_set_socket_functions(
        channel: *mut ares_channel_t,
        funcs: *const ares_socket_functions,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(u32)]
#[doc = " Flags defining behavior of socket functions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_sockfunc_flags_t {
    #[doc = " Strongly recommended to create sockets as non-blocking and set this\n  flag"]
    ARES_SOCKFUNC_FLAG_NONBLOCKING = 1,
}
#[repr(u32)]
#[doc = " Socket options in request to asetsockopt() in struct\n  ares_socket_functions_ex"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_socket_opt_t {
    #[doc = " Set the send buffer size. Value is a pointer to an int. (SO_SNDBUF)"]
    ARES_SOCKET_OPT_SENDBUF_SIZE = 0,
    #[doc = " Set the recv buffer size. Value is a pointer to an int. (SO_RCVBUF)"]
    ARES_SOCKET_OPT_RECVBUF_SIZE = 1,
    #[doc = " Set the network interface to use as the source for communication.\n  Value is a C string. (SO_BINDTODEVICE)"]
    ARES_SOCKET_OPT_BIND_DEVICE = 2,
    #[doc = " Enable TCP Fast Open.  Value is a pointer to an ares_bool_t.  On some\n  systems this could be a no-op if it is known it is on by default and\n  return success.  Other systems may be a no-op if known the system does\n  not support the feature and returns failure with errno set to ENOSYS or\n  WSASetLastError(WSAEOPNOTSUPP)."]
    ARES_SOCKET_OPT_TCP_FASTOPEN = 3,
}
#[repr(u32)]
#[doc = " Flags for behavior during connect"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_socket_connect_flags_t {
    #[doc = " Connect using TCP Fast Open"]
    ARES_SOCKET_CONN_TCP_FASTOPEN = 1,
}
#[repr(u32)]
#[doc = " Flags for behavior during bind"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_socket_bind_flags_t {
    #[doc = " Bind is for a TCP connection"]
    ARES_SOCKET_BIND_TCP = 1,
    #[doc = " Bind is for a client connection, not server"]
    ARES_SOCKET_BIND_CLIENT = 2,
}
#[doc = " Socket functions to call rather than using OS-native functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_socket_functions_ex {
    #[doc = " ABI Version: must be \"1\""]
    pub version: ::std::os::raw::c_uint,
    #[doc = " Flags indicating behavior of the subsystem. One or more\n ares_sockfunc_flags_t"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " REQUIRED. Create a new socket file descriptor.  The file descriptor must\n be opened in non-blocking mode (so that reads and writes never block).\n Recommended other options would be to disable signals on write errors\n (SO_NOSIGPIPE), Disable the Nagle algorithm on SOCK_STREAM (TCP_NODELAY),\n and to automatically close file descriptors on exec (FD_CLOEXEC).\n\n  \\param[in] domain      Socket domain. Valid values are AF_INET, AF_INET6.\n  \\param[in] type       Socket type. Valid values are SOCK_STREAM (tcp) and\n                        SOCK_DGRAM (udp).\n  \\param[in] protocol   In general this should be ignored, may be passed as\n                        0 (use as default for type), or may be IPPROTO_UDP\n                        or IPPROTO_TCP.\n  \\param[in] user_data  Pointer provided to ares_set_socket_functions_ex().\n  \\return ARES_SOCKET_BAD on error, or socket file descriptor on success.\n          On error, it is expected to set errno (or WSASetLastError()) to an\n          appropriate reason code such as EAFNOSUPPORT / WSAAFNOSUPPORT."]
    pub asocket: ::std::option::Option<
        unsafe extern "C" fn(
            domain: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            protocol: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ares_socket_t,
    >,
    #[doc = " REQUIRED. Close a socket file descriptor.\n  \\param[in] sock      Socket file descriptor returned from asocket.\n  \\param[in] user_data Pointer provided to ares_set_socket_functions_ex().\n  \\return 0 on success.  On failure, should set errno (or WSASetLastError)\n          to an appropriate code such as EBADF / WSAEBADF"]
    pub aclose: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " REQUIRED. Set socket option.  This shares a similar syntax to the BSD\n  setsockopt() call, however we use our own options.  The value is typically\n  a pointer to the desired value and each option has its own data type it\n  will express in the documentation.\n\n \\param[in] sock         Socket file descriptor returned from asocket.\n \\param[in] opt          Option to set.\n \\param[in] val          Pointer to value for option.\n \\param[in] val_size     Size of value.\n \\param[in] user_data    Pointer provided to\n ares_set_socket_functions_ex().\n \\return Return 0 on success, otherwise -1 should be returned with an\n         appropriate errno (or WSASetLastError()) set.  If error is ENOSYS /\n         WSAEOPNOTSUPP an error will not be propagated as it will take it\n         to mean it is an intentional decision to not support the feature."]
    pub asetsockopt: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            opt: ares_socket_opt_t,
            val: *const ::std::os::raw::c_void,
            val_size: ares_socklen_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " REQUIRED. Connect to the remote using the supplied address.  For UDP\n sockets this will bind the file descriptor to only send and receive packets\n from the remote address provided.\n\n  \\param[in] sock         Socket file descriptor returned from asocket.\n  \\param[in] address      Address to connect to\n  \\param[in] address_len  Size of address structure passed\n  \\param[in] flags        One or more ares_socket_connect_flags_t\n  \\param[in] user_data    Pointer provided to\n ares_set_socket_functions_ex().\n  \\return Return 0 upon successful establishement, otherwise -1 should be\n          returned with an appropriate errno (or WSASetLastError()) set.  It\n is generally expected that most TCP connections (not using TCP Fast Open)\n will return -1 with an error of EINPROGRESS / WSAEINPROGRESS due to the\n non-blocking nature of the connection.  It is then the responsibility of\n the implementation to notify of writability on the socket to indicate the\n connection has succeeded (or readability on failure to retrieve the\n appropriate error)."]
    pub aconnect: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            address: *const sockaddr,
            address_len: ares_socklen_t,
            flags: ::std::os::raw::c_uint,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " REQUIRED. Attempt to read data from the remote.\n\n  \\param[in]     sock        Socket file descriptor returned from asocket.\n  \\param[in,out] buffer      Allocated buffer to place data read from\n socket.\n  \\param[in]     length      Size of buffer\n  \\param[in]     flags       Unused, always 0.\n  \\param[in,out] address     Buffer to hold address data was received from.\n                             May be NULL if address not desired.\n  \\param[in,out] address_len Input size of address buffer, output actual\n                             written size. Must be NULL if address is NULL.\n  \\param[in]     user_data   Pointer provided to\n ares_set_socket_functions_ex().\n  \\return -1 on error with appropriate errno (or WSASetLastError()) set,\n such as EWOULDBLOCK / EAGAIN / WSAEWOULDBLOCK, or ECONNRESET /\n WSAECONNRESET."]
    pub arecvfrom: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            buffer: *mut ::std::os::raw::c_void,
            length: usize,
            flags: ::std::os::raw::c_int,
            address: *mut sockaddr,
            address_len: *mut ares_socklen_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ares_ssize_t,
    >,
    #[doc = " REQUIRED. Attempt to send data to the remote.  Optional address may be\n specified which may be useful on unbound UDP sockets (though currently not\n used), and TCP FastOpen where the connection is delayed until first write.\n\n  \\param[in]     sock        Socket file descriptor returned from asocket.\n  \\param[in]     buffer      Containing data to place onto wire.\n  \\param[in]     length      Size of buffer\n  \\param[in]     flags       Flags for writing.  Currently only used flag is\n                             MSG_NOSIGNAL if the host OS has such a flag. In\n                             general flags can be ignored.\n  \\param[in]     address     Buffer containing address to send data to.  May\n                             be NULL.\n  \\param[in,out] address_len Size of address buffer.  Must be 0 if address\n                             is NULL.\n  \\param[in]     user_data   Pointer provided to\n ares_set_socket_functions_ex().\n  \\return Number of bytes written. -1 on error with appropriate errno (or\n WSASetLastError()) set."]
    pub asendto: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            buffer: *const ::std::os::raw::c_void,
            length: usize,
            flags: ::std::os::raw::c_int,
            address: *const sockaddr,
            address_len: ares_socklen_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ares_ssize_t,
    >,
    #[doc = " Optional. Retrieve the local address of the socket.\n\n  \\param[in]     sock        Socket file descriptor returned from asocket\n  \\param[in,out] address     Buffer to hold address\n  \\param[in,out] address_len Size of address buffer on input, written size\n on output.\n  \\param[in]     user_data   Pointer provided to\n ares_set_socket_functions_ex().\n  \\return 0 on success. -1 on error with an appropriate errno (or\n WSASetLastError()) set."]
    pub agetsockname: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            address: *mut sockaddr,
            address_len: *mut ares_socklen_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Optional. Bind the socket to an address.  This can be used for client\n  connections to bind the source address for packets before connect, or\n  for server connections to bind to an address and port before listening.\n  Currently c-ares only supports client connections.\n\n  \\param[in] sock        Socket file descriptor returned from asocket\n  \\param[in] flags       ares_socket_bind_flags_t flags.\n  \\param[in] address     Buffer containing address.\n  \\param[in] address_len Size of address buffer.\n  \\param[in] user_data   Pointer provided to\n ares_set_socket_functions_ex().\n  \\return 0 on success. -1 on error with an appropriate errno (or\n WSASetLastError()) set."]
    pub abind: ::std::option::Option<
        unsafe extern "C" fn(
            sock: ares_socket_t,
            flags: ::std::os::raw::c_uint,
            address: *const sockaddr,
            address_len: socklen_t,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub aif_nametoindex: ::std::option::Option<
        unsafe extern "C" fn(
            ifname: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_uint,
    >,
    pub aif_indextoname: ::std::option::Option<
        unsafe extern "C" fn(
            ifindex: ::std::os::raw::c_uint,
            ifname_buf: *mut ::std::os::raw::c_char,
            ifname_buf_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char,
    >,
}
unsafe extern "C" {
    #[doc = " Override the native socket functions for the OS with the provided set.\n  An optional user data thunk may be specified which will be passed to\n  each registered callback.  Replaces ares_set_socket_functions().\n\n  \\param[in] channel   An initialized c-ares channel.\n  \\param[in] funcs     Structure registering the implementations for the\n                       various functions.  See the structure definition.\n                       This will be duplicated and does not need to exist\n                       past the life of this call.\n  \\param[in] user_data User data thunk which will be passed to each call of\n                       the registered callbacks.\n  \\return ARES_SUCCESS on success, or another error code such as ARES_EFORMERR\n          on misuse."]
    pub fn ares_set_socket_functions_ex(
        channel: *mut ares_channel_t,
        funcs: *const ares_socket_functions_ex,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ares_status_t;
}
unsafe extern "C" {
    pub fn ares_send(
        channel: *mut ares_channel_t,
        qbuf: *const ::std::os::raw::c_uchar,
        qlen: ::std::os::raw::c_int,
        callback: ares_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Send a DNS query as an ares_dns_record_t with a callback containing the\n  parsed DNS record.\n\n  \\param[in]  channel  Pointer to channel on which queries will be sent.\n  \\param[in]  dnsrec   DNS Record to send\n  \\param[in]  callback Callback function invoked on completion or failure of\n                       the query sequence.\n  \\param[in]  arg      Additional argument passed to the callback function.\n  \\param[out] qid      Query ID\n  \\return One of the c-ares status codes."]
    pub fn ares_send_dnsrec(
        channel: *mut ares_channel_t,
        dnsrec: *const ares_dns_record_t,
        callback: ares_callback_dnsrec,
        arg: *mut ::std::os::raw::c_void,
        qid: *mut ::std::os::raw::c_ushort,
    ) -> ares_status_t;
}
unsafe extern "C" {
    pub fn ares_query(
        channel: *mut ares_channel_t,
        name: *const ::std::os::raw::c_char,
        dnsclass: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        callback: ares_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Perform a DNS query with a callback containing the parsed DNS record.\n\n  \\param[in]  channel  Pointer to channel on which queries will be sent.\n  \\param[in]  name     Query name\n  \\param[in]  dnsclass DNS Class\n  \\param[in]  type     DNS Record Type\n  \\param[in]  callback Callback function invoked on completion or failure of\n                       the query sequence.\n  \\param[in]  arg      Additional argument passed to the callback function.\n  \\param[out] qid      Query ID\n  \\return One of the c-ares status codes."]
    pub fn ares_query_dnsrec(
        channel: *mut ares_channel_t,
        name: *const ::std::os::raw::c_char,
        dnsclass: ares_dns_class_t,
        type_: ares_dns_rec_type_t,
        callback: ares_callback_dnsrec,
        arg: *mut ::std::os::raw::c_void,
        qid: *mut ::std::os::raw::c_ushort,
    ) -> ares_status_t;
}
unsafe extern "C" {
    pub fn ares_search(
        channel: *mut ares_channel_t,
        name: *const ::std::os::raw::c_char,
        dnsclass: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        callback: ares_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Search for a complete DNS message.\n\n  \\param[in] channel  Pointer to channel on which queries will be sent.\n  \\param[in] dnsrec   Pointer to initialized and filled DNS record object.\n  \\param[in] callback Callback function invoked on completion or failure of\n                      the query sequence.\n  \\param[in] arg      Additional argument passed to the callback function.\n  \\return One of the c-ares status codes.  In all cases, except\n          ARES_EFORMERR due to misuse, this error code will also be sent\n          to the provided callback."]
    pub fn ares_search_dnsrec(
        channel: *mut ares_channel_t,
        dnsrec: *const ares_dns_record_t,
        callback: ares_callback_dnsrec,
        arg: *mut ::std::os::raw::c_void,
    ) -> ares_status_t;
}
unsafe extern "C" {
    pub fn ares_gethostbyname(
        channel: *mut ares_channel_t,
        name: *const ::std::os::raw::c_char,
        family: ::std::os::raw::c_int,
        callback: ares_host_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_gethostbyname_file(
        channel: *mut ares_channel_t,
        name: *const ::std::os::raw::c_char,
        family: ::std::os::raw::c_int,
        host: *mut *mut hostent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_gethostbyaddr(
        channel: *mut ares_channel_t,
        addr: *const ::std::os::raw::c_void,
        addrlen: ::std::os::raw::c_int,
        family: ::std::os::raw::c_int,
        callback: ares_host_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_getnameinfo(
        channel: *mut ares_channel_t,
        sa: *const sockaddr,
        salen: ares_socklen_t,
        flags: ::std::os::raw::c_int,
        callback: ares_nameinfo_callback,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ares_fds(
        channel: *const ares_channel_t,
        read_fds: *mut fd_set,
        write_fds: *mut fd_set,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_getsock(
        channel: *const ares_channel_t,
        socks: *mut ares_socket_t,
        numsocks: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_timeout(
        channel: *const ares_channel_t,
        maxtv: *mut timeval,
        tv: *mut timeval,
    ) -> *mut timeval;
}
unsafe extern "C" {
    pub fn ares_process(
        channel: *mut ares_channel_t,
        read_fds: *mut fd_set,
        write_fds: *mut fd_set,
    );
}
#[repr(u32)]
#[doc = " Events used by ares_fd_events_t"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_fd_eventflag_t {
    #[doc = "< No events"]
    ARES_FD_EVENT_NONE = 0,
    #[doc = "< Read event (including disconnect/error)"]
    ARES_FD_EVENT_READ = 1,
    #[doc = "< Write event"]
    ARES_FD_EVENT_WRITE = 2,
}
#[doc = " Type holding a file descriptor and mask of events, used by\n  ares_process_fds()"]
#[repr(C)]
pub struct ares_fd_events_t {
    #[doc = "< File descriptor"]
    pub fd: ares_socket_t,
    #[doc = "< Mask of ares_fd_eventflag_t"]
    pub events: ::std::os::raw::c_uint,
}
#[repr(u32)]
#[doc = " Flags used by ares_process_fds()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ares_process_flag_t {
    #[doc = "< No flag value"]
    ARES_PROCESS_FLAG_NONE = 0,
    #[doc = "< skip any processing unrelated to\n   the file descriptor events passed\n    in"]
    ARES_PROCESS_FLAG_SKIP_NON_FD = 1,
}
unsafe extern "C" {
    #[doc = " Process events on multiple file descriptors based on the event mask\n  associated with each file descriptor.  Recommended over calling\n  ares_process_fd() multiple times since it would trigger additional logic\n  such as timeout processing on each call.\n\n  \\param[in] channel  Initialized ares channel\n  \\param[in] events   Array of file descriptors with events.  May be NULL if\n                      no events, but may have timeouts to process.\n  \\param[in] nevents  Number of elements in the events array.  May be 0 if\n                      no events, but may have timeouts to process.\n  \\param[in] flags    Flags to alter behavior of the process command.\n  \\return ARES_ENOMEM on out of memory, ARES_EFORMERR on misuse,\n          otherwise ARES_SUCCESS"]
    pub fn ares_process_fds(
        channel: *mut ares_channel_t,
        events: *const ares_fd_events_t,
        nevents: usize,
        flags: ::std::os::raw::c_uint,
    ) -> ares_status_t;
}
unsafe extern "C" {
    pub fn ares_process_fd(
        channel: *mut ares_channel_t,
        read_fd: ares_socket_t,
        write_fd: ares_socket_t,
    );
}
unsafe extern "C" {
    pub fn ares_create_query(
        name: *const ::std::os::raw::c_char,
        dnsclass: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        id: ::std::os::raw::c_ushort,
        rd: ::std::os::raw::c_int,
        buf: *mut *mut ::std::os::raw::c_uchar,
        buflen: *mut ::std::os::raw::c_int,
        max_udp_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_mkquery(
        name: *const ::std::os::raw::c_char,
        dnsclass: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        id: ::std::os::raw::c_ushort,
        rd: ::std::os::raw::c_int,
        buf: *mut *mut ::std::os::raw::c_uchar,
        buflen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_expand_name(
        encoded: *const ::std::os::raw::c_uchar,
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        s: *mut *mut ::std::os::raw::c_char,
        enclen: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_expand_string(
        encoded: *const ::std::os::raw::c_uchar,
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        s: *mut *mut ::std::os::raw::c_uchar,
        enclen: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ares_addrttl {
    pub ipaddr: in_addr,
    pub ttl: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ares_addr6ttl {
    pub ip6addr: ares_in6_addr,
    pub ttl: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_caa_reply {
    pub next: *mut ares_caa_reply,
    pub critical: ::std::os::raw::c_int,
    pub property: *mut ::std::os::raw::c_uchar,
    pub plength: usize,
    pub value: *mut ::std::os::raw::c_uchar,
    pub length: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_srv_reply {
    pub next: *mut ares_srv_reply,
    pub host: *mut ::std::os::raw::c_char,
    pub priority: ::std::os::raw::c_ushort,
    pub weight: ::std::os::raw::c_ushort,
    pub port: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_mx_reply {
    pub next: *mut ares_mx_reply,
    pub host: *mut ::std::os::raw::c_char,
    pub priority: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_txt_reply {
    pub next: *mut ares_txt_reply,
    pub txt: *mut ::std::os::raw::c_uchar,
    pub length: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_txt_ext {
    pub next: *mut ares_txt_ext,
    pub txt: *mut ::std::os::raw::c_uchar,
    pub length: usize,
    pub record_start: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_naptr_reply {
    pub next: *mut ares_naptr_reply,
    pub flags: *mut ::std::os::raw::c_uchar,
    pub service: *mut ::std::os::raw::c_uchar,
    pub regexp: *mut ::std::os::raw::c_uchar,
    pub replacement: *mut ::std::os::raw::c_char,
    pub order: ::std::os::raw::c_ushort,
    pub preference: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_soa_reply {
    pub nsname: *mut ::std::os::raw::c_char,
    pub hostmaster: *mut ::std::os::raw::c_char,
    pub serial: ::std::os::raw::c_uint,
    pub refresh: ::std::os::raw::c_uint,
    pub retry: ::std::os::raw::c_uint,
    pub expire: ::std::os::raw::c_uint,
    pub minttl: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_uri_reply {
    pub next: *mut ares_uri_reply,
    pub priority: ::std::os::raw::c_ushort,
    pub weight: ::std::os::raw::c_ushort,
    pub uri: *mut ::std::os::raw::c_char,
    pub ttl: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ares_addrinfo_node {
    pub ai_ttl: ::std::os::raw::c_int,
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: ares_socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut ares_addrinfo_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_addrinfo_cname {
    pub ttl: ::std::os::raw::c_int,
    pub alias: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub next: *mut ares_addrinfo_cname,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_addrinfo {
    pub cnames: *mut ares_addrinfo_cname,
    pub nodes: *mut ares_addrinfo_node,
    #[cfg(cares1_18)]
    pub name: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ares_addrinfo_hints {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn ares_parse_a_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        host: *mut *mut hostent,
        addrttls: *mut ares_addrttl,
        naddrttls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_aaaa_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        host: *mut *mut hostent,
        addrttls: *mut ares_addr6ttl,
        naddrttls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_caa_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        caa_out: *mut *mut ares_caa_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_ptr_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        addr: *const ::std::os::raw::c_void,
        addrlen: ::std::os::raw::c_int,
        family: ::std::os::raw::c_int,
        host: *mut *mut hostent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_ns_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        host: *mut *mut hostent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_srv_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        srv_out: *mut *mut ares_srv_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_mx_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        mx_out: *mut *mut ares_mx_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_txt_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        txt_out: *mut *mut ares_txt_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_txt_reply_ext(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        txt_out: *mut *mut ares_txt_ext,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_naptr_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        naptr_out: *mut *mut ares_naptr_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_soa_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        soa_out: *mut *mut ares_soa_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_parse_uri_reply(
        abuf: *const ::std::os::raw::c_uchar,
        alen: ::std::os::raw::c_int,
        uri_out: *mut *mut ares_uri_reply,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_free_string(str_: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn ares_free_hostent(host: *mut hostent);
}
unsafe extern "C" {
    pub fn ares_free_data(dataptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn ares_strerror(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ares_addr_node {
    pub next: *mut ares_addr_node,
    pub family: ::std::os::raw::c_int,
    pub addr: ares_addr_node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ares_addr_node__bindgen_ty_1 {
    pub addr4: in_addr,
    pub addr6: ares_in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ares_addr_port_node {
    pub next: *mut ares_addr_port_node,
    pub family: ::std::os::raw::c_int,
    pub addr: ares_addr_port_node__bindgen_ty_1,
    pub udp_port: ::std::os::raw::c_int,
    pub tcp_port: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ares_addr_port_node__bindgen_ty_1 {
    pub addr4: in_addr,
    pub addr6: ares_in6_addr,
}
unsafe extern "C" {
    pub fn ares_set_servers(
        channel: *mut ares_channel_t,
        servers: *const ares_addr_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_set_servers_ports(
        channel: *mut ares_channel_t,
        servers: *const ares_addr_port_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_set_servers_csv(
        channel: *mut ares_channel_t,
        servers: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_set_servers_ports_csv(
        channel: *mut ares_channel_t,
        servers: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_get_servers_csv(channel: *const ares_channel_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ares_get_servers(
        channel: *const ares_channel_t,
        servers: *mut *mut ares_addr_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_get_servers_ports(
        channel: *const ares_channel_t,
        servers: *mut *mut ares_addr_port_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ares_inet_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        size: ares_socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ares_inet_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether or not the c-ares library was built with threadsafety\n\n  \\return ARES_TRUE if built with threadsafety, ARES_FALSE if not"]
    pub fn ares_threadsafety() -> ares_bool_t;
}
unsafe extern "C" {
    #[doc = " Block until notified that there are no longer any queries in queue, or\n  the specified timeout has expired.\n\n  \\param[in] channel    Initialized ares channel\n  \\param[in] timeout_ms Number of milliseconds to wait for the queue to be\n                        empty. -1 for Infinite.\n  \\return ARES_ENOTIMP if not built with threading support, ARES_ETIMEOUT\n          if requested timeout expires, ARES_SUCCESS when queue is empty."]
    pub fn ares_queue_wait_empty(
        channel: *mut ares_channel_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ares_status_t;
}
unsafe extern "C" {
    #[doc = " Retrieve the total number of active queries pending answers from servers.\n  Some c-ares requests may spawn multiple queries, such as ares_getaddrinfo()\n  when using AF_UNSPEC, which will be reflected in this number.\n\n  \\param[in] channel Initialized ares channel\n  \\return Number of active queries to servers"]
    pub fn ares_queue_active_queries(channel: *const ares_channel_t) -> usize;
}
#[cfg(target_os = "android")]
extern "C" {
    pub fn ares_library_init_jvm(jvm: *mut jni_sys::JavaVM);
}
#[cfg(target_os = "android")]
extern "C" {
    pub fn ares_library_init_android(
        connectivity_manager: jni_sys::jobject,
    ) -> ::std::os::raw::c_int;
}
#[cfg(target_os = "android")]
extern "C" {
    pub fn ares_library_android_initialized() -> ::std::os::raw::c_int;
}
